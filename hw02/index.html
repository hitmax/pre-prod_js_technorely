<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

<div>
    <p>В файле call_via_apply.js вам необходимо вызывать функцию sum очень хитрым способом :)
        Вызовите данную функцую используя функцию call через apply. В консоли должны увидеть вывоад типа Number.
        Подсказка: sum.call.apply.
    </p>


    <p>В файле bind.js напишите свой вариант метода bind. Который будет принимать функцию, которую неободимо обернуть. А
        в остальном работать так же как и нативный bind.
    </p>


    <p>В файле discount.js напишите функцию, которая принимает скидку в процентах(число) и возвращает функцию, которая,
        в свою очередь принимает стоимость товара(число), и возвращает сумму учитывая вашу скидку. Сделайте несколько
        вариантов. Для скидки в 10% и в 90%.
    </p>


    <p>В файле closure.js. Представьте, что у вас есть какая то функция с тяжелыми вычеслениями, которая надолго
        забивает main thread. Но при одинаковом входном параметре - результат ее выполнения - один и тот же. Создайте
        функцию мемоизации, которая будет принимать эту "тяжелую" функцию как аргумент, при этом в своем замыкании будет
        хранить кэш объект. И возвратит новую функцию. Если в возвращенную функцию при её вызове передать входной
        параметр, с которым она уже вызывалась ранее - эта функция должна избежать выполнения "тяжелой" функции и сразу
        вернуть результат из кэша.
    </p>
</div>


<script src="discount.js"></script>
<script src="bind.js"></script>
<script src="call_via_apply.js"></script>
<script src="closure.js"></script>
</body>
</html>